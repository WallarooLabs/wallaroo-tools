""" 
*******************************
THIS IS GENERATED CODE.
DO NOT EDIT THIS FILE DIRECTLY.
EDIT .wproto FILES INSTEAD.
*******************************
"""

use "buffered"
use "collections"

class val OuterThing is (Hashable & Equatable[OuterThing])
  let a_u32: U32
  let a_u64: U64
  let an_i32: I32
  let an_i64: I64
  let an_f32: F32
  let an_f64: F64
  let a_bool: Bool
  let a_string: String
  let an_array: Array[U64] val
  let an_array_of_arrays: Array[Array[U32] val] val
  let an_inner_thing: InnerThing val

  new val create(a_u32': U32, a_u64': U64, an_i32': I32, an_i64': I64, an_f32': F32, an_f64': F64, a_bool': Bool, a_string': String, an_array': Array[U64] val, an_array_of_arrays': Array[Array[U32] val] val, an_inner_thing': InnerThing val) =>
    a_u32 = a_u32'
    a_u64 = a_u64'
    an_i32 = an_i32'
    an_i64 = an_i64'
    an_f32 = an_f32'
    an_f64 = an_f64'
    a_bool = a_bool'
    a_string = a_string'
    an_array = an_array'
    an_array_of_arrays = an_array_of_arrays'
    an_inner_thing = an_inner_thing'

  fun eq(that: box->OuterThing): Bool =>
    (a_u32 == that.a_u32) and (a_u64 == that.a_u64) and (an_i32 == that.an_i32) and (an_i64 == that.an_i64) and (an_f32 == that.an_f32) and (an_f64 == that.an_f64) and (a_bool == that.a_bool) and (a_string == that.a_string) and true and true and (an_inner_thing == that.an_inner_thing)

  fun hash(): USize =>
    (a_u32.hash() xor a_u64.hash() xor an_i32.hash() xor an_i64.hash() xor an_f32.hash() xor an_f64.hash() xor a_bool.string().hash() xor a_string.hash() xor USize(0) xor USize(0) xor an_inner_thing.hash()).usize()

  fun string(): String iso^ =>
    ("OuterThing(a_u32:" + a_u32.string() + "|a_u64:" + a_u64.string() + "|an_i32:" + an_i32.string() + "|an_i64:" + an_i64.string() + "|an_f32:" + an_f32.string() + "|an_f64:" + an_f64.string() + "|a_bool:" + a_bool.string() + "|a_string:" + a_string + "|an_array:" + (var an_array_str = "[";for i in an_array.values() do an_array_str = an_array_str + i.string() end;an_array_str = an_array_str + "]"; an_array_str) + "|an_array_of_arrays:" + (var an_array_of_arrays_str = "[";for i in an_array_of_arrays.values() do an_array_of_arrays_str = an_array_of_arrays_str + (var i_str = "[";for xi in i.values() do i_str = i_str + xi.string() end;i_str = i_str + "]"; i_str) end;an_array_of_arrays_str = an_array_of_arrays_str + "]"; an_array_of_arrays_str) + "|an_inner_thing:" + an_inner_thing.string() + ")").clone()

primitive OuterThingEncoder
  fun apply(outerthing: OuterThing, wb: Writer = Writer): Array[ByteSeq] val =>
    from_fields(wb, outerthing.a_u32, outerthing.a_u64, outerthing.an_i32, outerthing.an_i64, outerthing.an_f32, outerthing.an_f64, outerthing.a_bool, outerthing.a_string, outerthing.an_array, outerthing.an_array_of_arrays, outerthing.an_inner_thing)

  fun from_fields(wb: Writer, a_u32: U32, a_u64: U64, an_i32: I32, an_i64: I64, an_f32: F32, an_f64: F64, a_bool: Bool, a_string: String, an_array: Array[U64] val, an_array_of_arrays: Array[Array[U32] val] val, an_inner_thing: InnerThing val): Array[ByteSeq] val =>
    let payload_size: USize = 4 + 8 + 4 + 8 + 4 + 8 + 1 + 4 + a_string.size() + (var an_array_size: USize = 4;for i in an_array.values() do an_array_size = an_array_size + 8 end;an_array_size) + (var an_array_of_arrays_size: USize = 4;for i in an_array_of_arrays.values() do an_array_of_arrays_size = an_array_of_arrays_size + (var i_size: USize = 4;for xi in i.values() do i_size = i_size + 4 end;i_size) end;an_array_of_arrays_size) + (var an_inner_thing_an_inner_array_size: USize = 4;for i in an_inner_thing.an_inner_array.values() do an_inner_thing_an_inner_array_size = an_inner_thing_an_inner_array_size + 4 + i.name.size() end;an_inner_thing_an_inner_array_size) + 8
    wb.u32_be(payload_size.u32())
    var next_size: USize = 0
    wb.u32_be(a_u32)
    wb.u64_be(a_u64)
    wb.i32_be(an_i32)
    wb.i64_be(an_i64)
    wb.f32_be(an_f32)
    wb.f64_be(an_f64)
    (if a_bool then wb.u8(1) else wb.u8(0) end)
    next_size = a_string.size()
    wb.u32_be(next_size.u32())
    wb.write(a_string)
    next_size = an_array.size()
    wb.u32_be(next_size.u32())
    for i in an_array.values() do
      wb.u64_be(i)
    end
    next_size = an_array_of_arrays.size()
    wb.u32_be(next_size.u32())
    for i in an_array_of_arrays.values() do
      next_size = i.size()
      wb.u32_be(next_size.u32())
      for xi in i.values() do
        wb.u32_be(xi)
      end
    end
    next_size = an_inner_thing.an_inner_array.size()
    wb.u32_be(next_size.u32())
    for i in an_inner_thing.an_inner_array.values() do
      next_size = i.name.size()
      wb.u32_be(next_size.u32())
      wb.write(i.name)
    end
    wb.u64_be(an_inner_thing.age)
    wb.done()

primitive OuterThingDecoder
  fun apply(data: Array[U8] val, rb: Reader = Reader): OuterThing ? =>
    var next_size: USize = 0
    rb.append(data)
    let a_u32 = rb.u32_be()?
    let a_u64 = rb.u64_be()?
    let an_i32 = rb.i32_be()?
    let an_i64 = rb.i64_be()?
    let an_f32 = rb.f32_be()?
    let an_f64 = rb.f64_be()?
    let a_bool = (if rb.u8()? == 1 then true else false end)
    next_size = rb.u32_be()?.usize()
    let a_string = String.from_array(rb.block(next_size)?)
    let an_array_iso = recover iso Array[U64] end
    let an_array_size: USize = rb.u32_be()?.usize()
    for _ in Range(0, an_array_size) do
      let xan_array = rb.u64_be()?
      an_array_iso.push(xan_array)
    end
    let an_array = consume val an_array_iso
    let an_array_of_arrays_iso = recover iso Array[Array[U32] val] end
    let an_array_of_arrays_size: USize = rb.u32_be()?.usize()
    for _ in Range(0, an_array_of_arrays_size) do
      let xan_array_of_arrays_iso = recover iso Array[U32] end
      let xan_array_of_arrays_size: USize = rb.u32_be()?.usize()
      for _ in Range(0, xan_array_of_arrays_size) do
        let xxan_array_of_arrays = rb.u32_be()?
        xan_array_of_arrays_iso.push(xxan_array_of_arrays)
      end
      let xan_array_of_arrays = consume val xan_array_of_arrays_iso
      an_array_of_arrays_iso.push(xan_array_of_arrays)
    end
    let an_array_of_arrays = consume val an_array_of_arrays_iso
    let an_inner_thing_an_inner_array_iso = recover iso Array[Item val] end
    let an_inner_thing_an_inner_array_size: USize = rb.u32_be()?.usize()
    for _ in Range(0, an_inner_thing_an_inner_array_size) do
      next_size = rb.u32_be()?.usize()
      let xan_inner_thing_an_inner_array_name = String.from_array(rb.block(next_size)?)
      let xan_inner_thing_an_inner_array = Item(xan_inner_thing_an_inner_array_name)
      an_inner_thing_an_inner_array_iso.push(xan_inner_thing_an_inner_array)
    end
    let an_inner_thing_an_inner_array = consume val an_inner_thing_an_inner_array_iso
    let an_inner_thing_age = rb.u64_be()?
    let an_inner_thing = InnerThing(an_inner_thing_an_inner_array, an_inner_thing_age)
    OuterThing(a_u32, a_u64, an_i32, an_i64, an_f32, an_f64, a_bool, a_string, an_array, an_array_of_arrays, an_inner_thing)

primitive OuterThingStringOutputEncoder
  fun apply(outerthing: OuterThing, wb: Writer = Writer): Array[ByteSeq] val =>
    wb.write(outerthing.string() + "\n")
    wb.done()

class val InnerThing is (Hashable & Equatable[InnerThing])
  let an_inner_array: Array[Item val] val
  let age: U64

  new val create(an_inner_array': Array[Item val] val, age': U64) =>
    an_inner_array = an_inner_array'
    age = age'

  fun eq(that: box->InnerThing): Bool =>
    true and (age == that.age)

  fun hash(): USize =>
    (USize(0) xor age.hash()).usize()

  fun string(): String iso^ =>
    ("InnerThing(an_inner_array:" + (var an_inner_array_str = "[";for i in an_inner_array.values() do an_inner_array_str = an_inner_array_str + i.string() end;an_inner_array_str = an_inner_array_str + "]"; an_inner_array_str) + "|age:" + age.string() + ")").clone()

primitive InnerThingEncoder
  fun apply(innerthing: InnerThing, wb: Writer = Writer): Array[ByteSeq] val =>
    from_fields(wb, innerthing.an_inner_array, innerthing.age)

  fun from_fields(wb: Writer, an_inner_array: Array[Item val] val, age: U64): Array[ByteSeq] val =>
    let payload_size: USize = (var an_inner_array_size: USize = 4;for i in an_inner_array.values() do an_inner_array_size = an_inner_array_size + 4 + i.name.size() end;an_inner_array_size) + 8
    wb.u32_be(payload_size.u32())
    var next_size: USize = 0
    next_size = an_inner_array.size()
    wb.u32_be(next_size.u32())
    for i in an_inner_array.values() do
      next_size = i.name.size()
      wb.u32_be(next_size.u32())
      wb.write(i.name)
    end
    wb.u64_be(age)
    wb.done()

primitive InnerThingDecoder
  fun apply(data: Array[U8] val, rb: Reader = Reader): InnerThing ? =>
    var next_size: USize = 0
    rb.append(data)
    let an_inner_array_iso = recover iso Array[Item val] end
    let an_inner_array_size: USize = rb.u32_be()?.usize()
    for _ in Range(0, an_inner_array_size) do
      next_size = rb.u32_be()?.usize()
      let xan_inner_array_name = String.from_array(rb.block(next_size)?)
      let xan_inner_array = Item(xan_inner_array_name)
      an_inner_array_iso.push(xan_inner_array)
    end
    let an_inner_array = consume val an_inner_array_iso
    let age = rb.u64_be()?
    InnerThing(an_inner_array, age)

primitive InnerThingStringOutputEncoder
  fun apply(innerthing: InnerThing, wb: Writer = Writer): Array[ByteSeq] val =>
    wb.write(innerthing.string() + "\n")
    wb.done()

class val Item is (Hashable & Equatable[Item])
  let name: String

  new val create(name': String) =>
    name = name'

  fun eq(that: box->Item): Bool =>
    (name == that.name)

  fun hash(): USize =>
    (name.hash()).usize()

  fun string(): String iso^ =>
    ("Item(name:" + name + ")").clone()

primitive ItemEncoder
  fun apply(item: Item, wb: Writer = Writer): Array[ByteSeq] val =>
    from_fields(wb, item.name)

  fun from_fields(wb: Writer, name: String): Array[ByteSeq] val =>
    let payload_size: USize = 4 + name.size()
    wb.u32_be(payload_size.u32())
    var next_size: USize = 0
    next_size = name.size()
    wb.u32_be(next_size.u32())
    wb.write(name)
    wb.done()

primitive ItemDecoder
  fun apply(data: Array[U8] val, rb: Reader = Reader): Item ? =>
    var next_size: USize = 0
    rb.append(data)
    next_size = rb.u32_be()?.usize()
    let name = String.from_array(rb.block(next_size)?)
    Item(name)

primitive ItemStringOutputEncoder
  fun apply(item: Item, wb: Writer = Writer): Array[ByteSeq] val =>
    wb.write(item.string() + "\n")
    wb.done()



